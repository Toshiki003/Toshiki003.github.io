---
layout: post
title:  "記事ステータス周りのメモ"
date:   2023-01-11 06:05:13 +0900
categories: 学習ログ
---

技術調査メモをここに残します。

* [rakeタスク](#sec1)
* [第２章](#sec2)
* [第３章](#sec3)



<a id="sec1"></a>
<h1>rakeタスク</h1>

Rakeとは、Rubyで書かれたコードをタスクとして作成しておき必要に応じて呼び出し実行することができる機能。

このRakeが実行する処理内容をRakeタスクと呼び、定義する場所をRakefileと呼ぶ。

- 利用場面

何かしらのデータの連携、DBバックアップ、定期的にデータを更新・削除するなどの**定型処理**

- Rakeタスクの作り方

```ruby
$ rails g task greet（ファイル名）
		create  lib/tasks/greet.rake
```

```ruby
lib/tasks/greet.rake内
namespace :greet do
end
↓  # 以下のように変更
namespace :greet do
  desc "Helloを表示するタスク"
  task say_hello: :environment do    # say_helloは自由に名称をつけることができる
    puts "Hello"
  end
end
```

descはタスク一覧を表示した時の説明文。`rake -T`

taskの後がタスクの名称と、ブロック内に実行する内容を書く。

- rakeタスクの実行

```ruby
$ rake greet:say_hello
		Hello
```

参考：

書籍「パーフェクトRuby on Rails」p21

[【Rails 】Rakeタスクとは]([https://qiita.com/mmaumtjgj/items/8384b6a26c97965bf047](https://qiita.com/mmaumtjgj/items/8384b6a26c97965bf047))
## cron, whenever
cron→クロン、またはクーロン。〜時になったら〇〇のコマンドを実行といった定期処理を実行するために、メモリ上で常に命令を待機しているプロセスのこと。UNIX系OS(MacOS含む)で標準的に利用される常駐プログラム＝デーモンの一種。

cronに対して命令を行うには、crontabに記述をする。ちなみにcrontabは”cron table”の略。

whenever→cronの設定をRuby言語で書けるようにしたライブラリのこと。gem wheneverを使ってcronの設定を行うようだ。

### wheneverでcronを編集する

- Gemfileに記述しbundle install

```ruby
gem 'whenever', require: false #解説
```

- Gemfileにrequire: falseをつける意味

今までスルーしていたけど、メモしておく。

解説：`require: false`を指定すると、自動読み込みしないようにする。

Rubocopだったり今回のwhenever は通常コマンドで使用するもので、Railsアプリの中からメソッドを呼び出すことはない。ということは自動読み込みさせる必要がないので、`require: false`にすればよいということ。

[Gemfile に書く require: false とは何か - No Solution for Life](https://masuyama13.hatenablog.com/entry/2021/01/10/225038)

この後の具体的なコマンドや流れは、参考にしたQiita記事を読んで進めていく。

### job_typeとは

### crontabの実行


## find_each
分割してレコードを取得して1件ずつ処理する。デフォルトでは1000件ずつ(!)処理し、大きなデータを持つモデルなどを処理する時に使う。(Railsドキュメント）

使用例

```ruby
User.find_each do |user|
  p user.id 
end
```

1万人のユーザー情報があったとき、1000件ずつレコードを取得することでメモリへの負担を減らす。

whereメソッドと併せて使うと、取得するレコードの条件を指定した後にfind_eachメソッドを使うことができる。また、オプションとして:batch_size, :start, :finishなどが用意されている。

詳しくは、[【Rails】 find_eachメソッドでメモリを節約して大量データを扱う方法]([https://pikawaka.com/rails/find_each#whereメソッドと使う](https://pikawaka.com/rails/find_each#where%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%81%A8%E4%BD%BF%E3%81%86))を参照。
## FatControllerの解消

→処理の流れが追いにくい状態。基本的にはモデルにロジックを寄せていく。ここでデザインパターンなる考え方が登場。

現状がFatな状態であるかどうか、コードを読んで確認する。

また、ログを確認し、SQLが頻繁に発行されていないかを調べていく。

# STI

**[Rails ActiveRecordのSTI(Single Table Inheritance)の使い方](https://easyramble.com/rails-activerecord-single-table-inheritance.html)**

****[【Rails】単一テーブル継承(STI)について(Qiita)](https://qiita.com/niwa1903/items/218713c076fb0075712f)****



要はクラスの継承のDB版。テーブルを少なくできるよ！同じような設計のテーブルは一つにまとめてDRYしようぜ、って話。ログで出されるSQLが大事っぽいから読み慣れしたいね。今のところ理解度で言うと20%ぐらい。



# ActiveStrage

Amazon S3などクラウドストレージサービスへのアップロードなどできる。また、アプリにアップした画像の変形、画像以外の動画から画像を生成したり、メタデータ抽出？にも利用できる。とRailsガイドより。要は結構便利ですよってこと。

ただ、Rails以外のサードパーティソフトウェアに依存しているから、別途インストールが必要。また、gem ‘image_processing’も必要。

- [ファイルをレコードに添付する](https://railsguides.jp/active_storage_overview.html#has-one-attached)　has_one_attached レコード1件ごとに1個のファイルを添付

カリキュラムのschemaを見ると、active_storage_blobsとactive_storage_attachmentsはテーブルがあるけれど、`active_storage_variant_records`は存在しなかった。あれ？Railsガイドと違うぞ？と思ったけれど、Railsガイド7系を読んでいた。実際に今使用しているのはRails5.2.3。バージョンが違うからActiveStrageで必要なテーブル数も違うというのが結論。

**Railsガイドを読むときは、バージョンをしっかり確認すること。**
<br>
<br>
<br>
<br>
articleモデルで言語化できないところを調べるうちに、STIやActiveStrageについてもざっくり理解できました。課題の記事ステータスの変更には関係ないかもしれないけれど、こうやって初めて触れるコードや概念を一つずつ理解していきます。